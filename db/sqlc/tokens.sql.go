// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: tokens.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/vocdoni/census3/db/annotations"
)

const createToken = `-- name: CreateToken :execresult
INSERT INTO Tokens (
    id,
    name,
    symbol,
    decimals,
    total_supply,
    creation_block,
    type_id
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
`

type CreateTokenParams struct {
	ID            annotations.Address
	Name          sql.NullString
	Symbol        sql.NullString
	Decimals      sql.NullInt32
	TotalSupply   annotations.BigInt
	CreationBlock int64
	TypeID        int64
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createToken,
		arg.ID,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.TotalSupply,
		arg.CreationBlock,
		arg.TypeID,
	)
}

const deleteToken = `-- name: DeleteToken :execresult
DELETE FROM Tokens
WHERE id = ?
`

func (q *Queries) DeleteToken(ctx context.Context, id annotations.Address) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteToken, id)
}

const paginatedTokens = `-- name: PaginatedTokens :many
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id FROM Tokens
ORDER BY type_id, name
LIMIT ? OFFSET ?
`

type PaginatedTokensParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) PaginatedTokens(ctx context.Context, arg PaginatedTokensParams) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, paginatedTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenByID = `-- name: TokenByID :one
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id FROM Tokens
WHERE id = ?
LIMIT 1
`

func (q *Queries) TokenByID(ctx context.Context, id annotations.Address) (Token, error) {
	row := q.db.QueryRowContext(ctx, tokenByID, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.TotalSupply,
		&i.CreationBlock,
		&i.TypeID,
	)
	return i, err
}

const tokenByName = `-- name: TokenByName :one
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id FROM Tokens
WHERE name = ?
LIMIT 1
`

func (q *Queries) TokenByName(ctx context.Context, name sql.NullString) (Token, error) {
	row := q.db.QueryRowContext(ctx, tokenByName, name)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.TotalSupply,
		&i.CreationBlock,
		&i.TypeID,
	)
	return i, err
}

const tokenBySymbol = `-- name: TokenBySymbol :one
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id FROM Tokens
WHERE symbol = ?
LIMIT 1
`

func (q *Queries) TokenBySymbol(ctx context.Context, symbol sql.NullString) (Token, error) {
	row := q.db.QueryRowContext(ctx, tokenBySymbol, symbol)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.TotalSupply,
		&i.CreationBlock,
		&i.TypeID,
	)
	return i, err
}

const tokensByStrategyID = `-- name: TokensByStrategyID :many
SELECT t.id, t.name, t.symbol, t.decimals, t.total_supply, t.creation_block, t.type_id, st.strategy_id, st.token_id, st.min_balance, st.method_hash FROM Tokens t
JOIN StrategyTokens st ON st.token_id = t.id
WHERE st.strategy_id = ?
ORDER BY t.name
LIMIT ? OFFSET ?
`

type TokensByStrategyIDParams struct {
	StrategyID int64
	Limit      int32
	Offset     int32
}

type TokensByStrategyIDRow struct {
	ID            annotations.Address
	Name          sql.NullString
	Symbol        sql.NullString
	Decimals      sql.NullInt32
	TotalSupply   annotations.BigInt
	CreationBlock int64
	TypeID        int64
	StrategyID    int64
	TokenID       annotations.Address
	MinBalance    annotations.BigInt
	MethodHash    annotations.MethodHash
}

func (q *Queries) TokensByStrategyID(ctx context.Context, arg TokensByStrategyIDParams) ([]TokensByStrategyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokensByStrategyID, arg.StrategyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokensByStrategyIDRow
	for rows.Next() {
		var i TokensByStrategyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
			&i.StrategyID,
			&i.TokenID,
			&i.MinBalance,
			&i.MethodHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokensByType = `-- name: TokensByType :many
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id FROM Tokens
WHERE type_id = ?
ORDER BY name
LIMIT ? OFFSET ?
`

type TokensByTypeParams struct {
	TypeID int64
	Limit  int32
	Offset int32
}

func (q *Queries) TokensByType(ctx context.Context, arg TokensByTypeParams) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, tokensByType, arg.TypeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToken = `-- name: UpdateToken :execresult
UPDATE Tokens
SET name = ?,
    symbol = ?,
    decimals = ?,
    total_supply = ?,
    creation_block = ?,
    type_id = ?
WHERE id = ?
`

type UpdateTokenParams struct {
	Name          sql.NullString
	Symbol        sql.NullString
	Decimals      sql.NullInt32
	TotalSupply   annotations.BigInt
	CreationBlock int64
	TypeID        int64
	ID            annotations.Address
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateToken,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.TotalSupply,
		arg.CreationBlock,
		arg.TypeID,
		arg.ID,
	)
}
