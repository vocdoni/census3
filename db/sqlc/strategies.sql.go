// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: strategies.sql

package queries

import (
	"context"
	"database/sql"
)

const createStategy = `-- name: CreateStategy :execresult
INSERT INTO strategies (predicate)
VALUES (?)
`

func (q *Queries) CreateStategy(ctx context.Context, predicate string) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStategy, predicate)
}

const createStrategyToken = `-- name: CreateStrategyToken :execresult
INSERT INTO strategy_tokens (
    strategy_id,
    token_id,
    min_balance,
    method_hash
)
VALUES (
    ?, ?, ?, ?
)
`

type CreateStrategyTokenParams struct {
	StrategyID uint64
	TokenID    []byte
	MinBalance []byte
	MethodHash []byte
}

func (q *Queries) CreateStrategyToken(ctx context.Context, arg CreateStrategyTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStrategyToken,
		arg.StrategyID,
		arg.TokenID,
		arg.MinBalance,
		arg.MethodHash,
	)
}

const deleteStrategy = `-- name: DeleteStrategy :execresult
DELETE FROM strategies
WHERE id = ?
`

func (q *Queries) DeleteStrategy(ctx context.Context, id uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteStrategy, id)
}

const deleteStrategyToken = `-- name: DeleteStrategyToken :execresult
DELETE FROM strategy_tokens
WHERE strategy_id = ? AND token_id = ?
`

type DeleteStrategyTokenParams struct {
	StrategyID uint64
	TokenID    []byte
}

func (q *Queries) DeleteStrategyToken(ctx context.Context, arg DeleteStrategyTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteStrategyToken, arg.StrategyID, arg.TokenID)
}

const listStrategies = `-- name: ListStrategies :many
SELECT id, predicate FROM strategies
ORDER BY id
`

func (q *Queries) ListStrategies(ctx context.Context) ([]Strategy, error) {
	rows, err := q.db.QueryContext(ctx, listStrategies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Strategy
	for rows.Next() {
		var i Strategy
		if err := rows.Scan(&i.ID, &i.Predicate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const strategiesByTokenID = `-- name: StrategiesByTokenID :many
SELECT s.id, s.predicate FROM strategies s
JOIN strategy_tokens st ON st.strategy_id = s.id
WHERE st.token_id = ?
ORDER BY s.id
`

func (q *Queries) StrategiesByTokenID(ctx context.Context, tokenID []byte) ([]Strategy, error) {
	rows, err := q.db.QueryContext(ctx, strategiesByTokenID, tokenID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Strategy
	for rows.Next() {
		var i Strategy
		if err := rows.Scan(&i.ID, &i.Predicate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const strategyByID = `-- name: StrategyByID :one
SELECT id, predicate FROM strategies
WHERE id = ?
LIMIT 1
`

func (q *Queries) StrategyByID(ctx context.Context, id uint64) (Strategy, error) {
	row := q.db.QueryRowContext(ctx, strategyByID, id)
	var i Strategy
	err := row.Scan(&i.ID, &i.Predicate)
	return i, err
}

const strategyByPredicate = `-- name: StrategyByPredicate :one
SELECT id, predicate FROM strategies
WHERE predicate = ?
LIMIT 1
`

func (q *Queries) StrategyByPredicate(ctx context.Context, predicate string) (Strategy, error) {
	row := q.db.QueryRowContext(ctx, strategyByPredicate, predicate)
	var i Strategy
	err := row.Scan(&i.ID, &i.Predicate)
	return i, err
}

const strategyTokenByStrategyIDAndTokenID = `-- name: StrategyTokenByStrategyIDAndTokenID :one
SELECT strategy_id, token_id, min_balance, method_hash
FROM strategy_tokens
WHERE strategy_id = ? AND token_id = ?
LIMIT 1
`

type StrategyTokenByStrategyIDAndTokenIDParams struct {
	StrategyID uint64
	TokenID    []byte
}

func (q *Queries) StrategyTokenByStrategyIDAndTokenID(ctx context.Context, arg StrategyTokenByStrategyIDAndTokenIDParams) (StrategyToken, error) {
	row := q.db.QueryRowContext(ctx, strategyTokenByStrategyIDAndTokenID, arg.StrategyID, arg.TokenID)
	var i StrategyToken
	err := row.Scan(
		&i.StrategyID,
		&i.TokenID,
		&i.MinBalance,
		&i.MethodHash,
	)
	return i, err
}

const strategyTokenByStrategyIDAndTokenIDAndMethodHash = `-- name: StrategyTokenByStrategyIDAndTokenIDAndMethodHash :one
SELECT strategy_id, token_id, min_balance, method_hash
FROM strategy_tokens
WHERE strategy_id = ? AND token_id = ? AND method_hash = ?
`

type StrategyTokenByStrategyIDAndTokenIDAndMethodHashParams struct {
	StrategyID uint64
	TokenID    []byte
	MethodHash []byte
}

func (q *Queries) StrategyTokenByStrategyIDAndTokenIDAndMethodHash(ctx context.Context, arg StrategyTokenByStrategyIDAndTokenIDAndMethodHashParams) (StrategyToken, error) {
	row := q.db.QueryRowContext(ctx, strategyTokenByStrategyIDAndTokenIDAndMethodHash, arg.StrategyID, arg.TokenID, arg.MethodHash)
	var i StrategyToken
	err := row.Scan(
		&i.StrategyID,
		&i.TokenID,
		&i.MinBalance,
		&i.MethodHash,
	)
	return i, err
}

const strategyTokens = `-- name: StrategyTokens :many
SELECT strategy_id, token_id, min_balance, method_hash
FROM strategy_tokens
ORDER BY strategy_id, token_id
`

func (q *Queries) StrategyTokens(ctx context.Context) ([]StrategyToken, error) {
	rows, err := q.db.QueryContext(ctx, strategyTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StrategyToken
	for rows.Next() {
		var i StrategyToken
		if err := rows.Scan(
			&i.StrategyID,
			&i.TokenID,
			&i.MinBalance,
			&i.MethodHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStrategy = `-- name: UpdateStrategy :execresult
UPDATE strategies
SET predicate = ?
WHERE id = ?
`

type UpdateStrategyParams struct {
	Predicate string
	ID        uint64
}

func (q *Queries) UpdateStrategy(ctx context.Context, arg UpdateStrategyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateStrategy, arg.Predicate, arg.ID)
}

const updateStrategyToken = `-- name: UpdateStrategyToken :execresult
UPDATE strategy_tokens
SET min_balance = ?,
    method_hash = ?
WHERE strategy_id = ? AND token_id = ?
`

type UpdateStrategyTokenParams struct {
	MinBalance []byte
	MethodHash []byte
	StrategyID uint64
	TokenID    []byte
}

func (q *Queries) UpdateStrategyToken(ctx context.Context, arg UpdateStrategyTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateStrategyToken,
		arg.MinBalance,
		arg.MethodHash,
		arg.StrategyID,
		arg.TokenID,
	)
}
