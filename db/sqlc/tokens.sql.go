// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: tokens.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/vocdoni/census3/db/annotations"
)

const createToken = `-- name: CreateToken :execresult
INSERT INTO tokens (
    id,
    name,
    symbol,
    decimals,
    total_supply,
    creation_block,
    type_id,
    synced,
    tags,
    chain_id
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateTokenParams struct {
	ID            annotations.Address
	Name          sql.NullString
	Symbol        sql.NullString
	Decimals      uint64
	TotalSupply   annotations.BigInt
	CreationBlock sql.NullInt64
	TypeID        uint64
	Synced        bool
	Tags          sql.NullString
	ChainID       uint64
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createToken,
		arg.ID,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.TotalSupply,
		arg.CreationBlock,
		arg.TypeID,
		arg.Synced,
		arg.Tags,
		arg.ChainID,
	)
}

const deleteToken = `-- name: DeleteToken :execresult
DELETE FROM tokens
WHERE id = ?
`

func (q *Queries) DeleteToken(ctx context.Context, id annotations.Address) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteToken, id)
}

const existsToken = `-- name: ExistsToken :one
SELECT EXISTS 
    (SELECT id 
    FROM tokens
    WHERE id = ?)
`

func (q *Queries) ExistsToken(ctx context.Context, id annotations.Address) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsToken, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listTokens = `-- name: ListTokens :many
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
ORDER BY id ASC 
LIMIT ?
`

func (q *Queries) ListTokens(ctx context.Context, limit int32) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, listTokens, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
			&i.Synced,
			&i.Tags,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensNextCursor = `-- name: ListTokensNextCursor :one
SELECT id FROM (
    SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
    WHERE tokens.id > ?
    ORDER BY id ASC 
    LIMIT ?
) AS next_cursor ORDER BY id DESC LIMIT 1
`

type ListTokensNextCursorParams struct {
	PageCursor annotations.Address
	Limit      int32
}

func (q *Queries) ListTokensNextCursor(ctx context.Context, arg ListTokensNextCursorParams) (annotations.Address, error) {
	row := q.db.QueryRowContext(ctx, listTokensNextCursor, arg.PageCursor, arg.Limit)
	var id annotations.Address
	err := row.Scan(&id)
	return id, err
}

const listTokensPaginated = `-- name: ListTokensPaginated :many
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
WHERE id >= ?
ORDER BY id ASC 
LIMIT ?
`

type ListTokensPaginatedParams struct {
	PageCursor annotations.Address
	Limit      int32
}

func (q *Queries) ListTokensPaginated(ctx context.Context, arg ListTokensPaginatedParams) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, listTokensPaginated, arg.PageCursor, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
			&i.Synced,
			&i.Tags,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensPrevCursor = `-- name: ListTokensPrevCursor :one
SELECT id FROM (
    SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
    WHERE tokens.id <= ?
    ORDER BY id ASC 
    LIMIT ?
) AS prev_cursor ORDER BY id ASC LIMIT 1
`

type ListTokensPrevCursorParams struct {
	PageCursor annotations.Address
	Limit      int32
}

func (q *Queries) ListTokensPrevCursor(ctx context.Context, arg ListTokensPrevCursorParams) (annotations.Address, error) {
	row := q.db.QueryRowContext(ctx, listTokensPrevCursor, arg.PageCursor, arg.Limit)
	var id annotations.Address
	err := row.Scan(&id)
	return id, err
}

const tokenByID = `-- name: TokenByID :one
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
WHERE id = ?
LIMIT 1
`

func (q *Queries) TokenByID(ctx context.Context, id annotations.Address) (Token, error) {
	row := q.db.QueryRowContext(ctx, tokenByID, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.TotalSupply,
		&i.CreationBlock,
		&i.TypeID,
		&i.Synced,
		&i.Tags,
		&i.ChainID,
	)
	return i, err
}

const tokenByName = `-- name: TokenByName :one
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
WHERE name = ?
LIMIT 1
`

func (q *Queries) TokenByName(ctx context.Context, name sql.NullString) (Token, error) {
	row := q.db.QueryRowContext(ctx, tokenByName, name)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.TotalSupply,
		&i.CreationBlock,
		&i.TypeID,
		&i.Synced,
		&i.Tags,
		&i.ChainID,
	)
	return i, err
}

const tokenBySymbol = `-- name: TokenBySymbol :one
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
WHERE symbol = ?
LIMIT 1
`

func (q *Queries) TokenBySymbol(ctx context.Context, symbol sql.NullString) (Token, error) {
	row := q.db.QueryRowContext(ctx, tokenBySymbol, symbol)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.TotalSupply,
		&i.CreationBlock,
		&i.TypeID,
		&i.Synced,
		&i.Tags,
		&i.ChainID,
	)
	return i, err
}

const tokensByStrategyID = `-- name: TokensByStrategyID :many
SELECT t.id, t.name, t.symbol, t.decimals, t.total_supply, t.creation_block, t.type_id, t.synced, t.tags, t.chain_id, st.strategy_id, st.token_id, st.min_balance, st.method_hash FROM tokens t
JOIN strategy_tokens st ON st.token_id = t.id
WHERE st.strategy_id = ?
ORDER BY t.name
`

type TokensByStrategyIDRow struct {
	ID            annotations.Address
	Name          sql.NullString
	Symbol        sql.NullString
	Decimals      uint64
	TotalSupply   annotations.BigInt
	CreationBlock sql.NullInt64
	TypeID        uint64
	Synced        bool
	Tags          sql.NullString
	ChainID       uint64
	StrategyID    uint64
	TokenID       []byte
	MinBalance    []byte
	MethodHash    []byte
}

func (q *Queries) TokensByStrategyID(ctx context.Context, strategyID uint64) ([]TokensByStrategyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokensByStrategyID, strategyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokensByStrategyIDRow
	for rows.Next() {
		var i TokensByStrategyIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
			&i.Synced,
			&i.Tags,
			&i.ChainID,
			&i.StrategyID,
			&i.TokenID,
			&i.MinBalance,
			&i.MethodHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokensByType = `-- name: TokensByType :many
SELECT id, name, symbol, decimals, total_supply, creation_block, type_id, synced, tags, chain_id FROM tokens
WHERE type_id = ?
ORDER BY name
`

func (q *Queries) TokensByType(ctx context.Context, typeID uint64) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, tokensByType, typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
			&i.Synced,
			&i.Tags,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToken = `-- name: UpdateToken :execresult
UPDATE tokens
SET name = ?,
    symbol = ?,
    decimals = ?,
    total_supply = ?,
    creation_block = ?,
    type_id = ?,
    synced = ?,
    tags = ?
WHERE id = ?
`

type UpdateTokenParams struct {
	Name          sql.NullString
	Symbol        sql.NullString
	Decimals      uint64
	TotalSupply   annotations.BigInt
	CreationBlock sql.NullInt64
	TypeID        uint64
	Synced        bool
	Tags          sql.NullString
	ID            annotations.Address
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateToken,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.TotalSupply,
		arg.CreationBlock,
		arg.TypeID,
		arg.Synced,
		arg.Tags,
		arg.ID,
	)
}

const updateTokenCreationBlock = `-- name: UpdateTokenCreationBlock :execresult
UPDATE tokens
SET creation_block = ?
WHERE id = ?
`

type UpdateTokenCreationBlockParams struct {
	CreationBlock sql.NullInt64
	ID            annotations.Address
}

func (q *Queries) UpdateTokenCreationBlock(ctx context.Context, arg UpdateTokenCreationBlockParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTokenCreationBlock, arg.CreationBlock, arg.ID)
}

const updateTokenStatus = `-- name: UpdateTokenStatus :execresult
UPDATE tokens
SET synced = ?
WHERE id = ?
`

type UpdateTokenStatusParams struct {
	Synced bool
	ID     annotations.Address
}

func (q *Queries) UpdateTokenStatus(ctx context.Context, arg UpdateTokenStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTokenStatus, arg.Synced, arg.ID)
}
