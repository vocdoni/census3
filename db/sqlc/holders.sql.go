// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: holders.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/vocdoni/census3/db/annotations"
)

const aNDOperator = `-- name: ANDOperator :many
;WITH holders_a as (
    SELECT th.holder_id, th.balance
    FROM token_holders th
    WHERE th.token_id = ? 
        AND th.chain_id = ?
        AND th.balance >= ?
),
holders_b as (
    SELECT th.holder_id, th.balance
    FROM token_holders th
    WHERE th.token_id = ? 
        AND th.chain_id = ?
        AND th.balance >= ?
)
SELECT holders_a.holder_id, holders_a.balance as balance_a, holders_b.balance as balance_b
FROM holders_a
INNER JOIN holders_b ON holders_a.holder_id = holders_b.holder_id
`

type ANDOperatorParams struct {
	TokenIDA    annotations.Address
	ChainIDA    uint64
	MinBalanceA []byte
	TokenIDB    annotations.Address
	ChainIDB    uint64
	MinBalanceB []byte
}

type ANDOperatorRow struct {
	HolderID []byte
	BalanceA []byte
	BalanceB []byte
}

func (q *Queries) ANDOperator(ctx context.Context, arg ANDOperatorParams) ([]ANDOperatorRow, error) {
	rows, err := q.db.QueryContext(ctx, aNDOperator,
		arg.TokenIDA,
		arg.ChainIDA,
		arg.MinBalanceA,
		arg.TokenIDB,
		arg.ChainIDB,
		arg.MinBalanceB,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ANDOperatorRow
	for rows.Next() {
		var i ANDOperatorRow
		if err := rows.Scan(&i.HolderID, &i.BalanceA, &i.BalanceB); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countTokenHolders = `-- name: CountTokenHolders :one
SELECT COUNT(holder_id) 
FROM token_holders
WHERE token_id = ?
    AND chain_id = ?
    AND external_id = ?
`

type CountTokenHoldersParams struct {
	TokenID    annotations.Address
	ChainID    uint64
	ExternalID string
}

func (q *Queries) CountTokenHolders(ctx context.Context, arg CountTokenHoldersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTokenHolders, arg.TokenID, arg.ChainID, arg.ExternalID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHolder = `-- name: CreateHolder :execresult
INSERT INTO holders (id)
VALUES (?)
`

func (q *Queries) CreateHolder(ctx context.Context, id annotations.Address) (sql.Result, error) {
	return q.db.ExecContext(ctx, createHolder, id)
}

const createTokenHolder = `-- name: CreateTokenHolder :execresult
INSERT INTO token_holders (
    token_id,
    holder_id,
    balance,
    block_id,
    chain_id,
    external_id
)
VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateTokenHolderParams struct {
	TokenID    annotations.Address
	HolderID   annotations.Address
	Balance    []byte
	BlockID    uint64
	ChainID    uint64
	ExternalID string
}

func (q *Queries) CreateTokenHolder(ctx context.Context, arg CreateTokenHolderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTokenHolder,
		arg.TokenID,
		arg.HolderID,
		arg.Balance,
		arg.BlockID,
		arg.ChainID,
		arg.ExternalID,
	)
}

const deleteTokenHolder = `-- name: DeleteTokenHolder :execresult
DELETE FROM token_holders
WHERE token_id = ? 
    AND holder_id = ? 
    AND block_id = ?
    AND chain_id = ?
    AND external_id = ?
`

type DeleteTokenHolderParams struct {
	TokenID    annotations.Address
	HolderID   annotations.Address
	BlockID    uint64
	ChainID    uint64
	ExternalID string
}

func (q *Queries) DeleteTokenHolder(ctx context.Context, arg DeleteTokenHolderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTokenHolder,
		arg.TokenID,
		arg.HolderID,
		arg.BlockID,
		arg.ChainID,
		arg.ExternalID,
	)
}

const existTokenHolder = `-- name: ExistTokenHolder :one
SELECT EXISTS (
    SELECT holder_id 
    FROM token_holders
    WHERE token_id = ? 
        AND holder_id = ?
        AND chain_id = ?
        AND external_id = ?
)
`

type ExistTokenHolderParams struct {
	TokenID    annotations.Address
	HolderID   annotations.Address
	ChainID    uint64
	ExternalID string
}

func (q *Queries) ExistTokenHolder(ctx context.Context, arg ExistTokenHolderParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existTokenHolder,
		arg.TokenID,
		arg.HolderID,
		arg.ChainID,
		arg.ExternalID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const lastBlockByTokenID = `-- name: LastBlockByTokenID :one
SELECT block_id 
FROM token_holders
WHERE token_id = ?
ORDER BY block_id DESC
LIMIT 1
`

func (q *Queries) LastBlockByTokenID(ctx context.Context, tokenID annotations.Address) (uint64, error) {
	row := q.db.QueryRowContext(ctx, lastBlockByTokenID, tokenID)
	var block_id uint64
	err := row.Scan(&block_id)
	return block_id, err
}

const oROperator = `-- name: OROperator :many
SELECT holder_ids.holder_id, a.balance AS balance_a, b.balance AS balance_b
FROM (
    SELECT th.holder_id
    FROM token_holders th
    WHERE (
        th.token_id = ? 
        AND th.chain_id = ?
        AND th.balance >= ?
    ) OR (
        th.token_id = ? 
        AND th.chain_id = ?
        AND th.balance >= ?
    )
) as holder_ids
LEFT JOIN (
    SELECT th_b.holder_id, th_b.balance
    FROM token_holders th_b
    WHERE th_b.token_id = ? 
        AND th_b.chain_id = ?
        AND th_b.balance >= ?
) AS a ON holder_ids.holder_id = a.holder_id
LEFT JOIN (
    SELECT th_a.holder_id, th_a.balance
    FROM token_holders th_a
    WHERE th_a.token_id = ? 
        AND th_a.chain_id = ?
        AND th_a.balance >= ?
) AS b ON holder_ids.holder_id = b.holder_id
GROUP BY holder_ids.holder_id
`

type OROperatorParams struct {
	TokenIDA    annotations.Address
	ChainIDA    uint64
	MinBalanceA []byte
	TokenIDB    annotations.Address
	ChainIDB    uint64
	MinBalanceB []byte
}

type OROperatorRow struct {
	HolderID annotations.Address
	BalanceA []byte
	BalanceB []byte
}

func (q *Queries) OROperator(ctx context.Context, arg OROperatorParams) ([]OROperatorRow, error) {
	rows, err := q.db.QueryContext(ctx, oROperator,
		arg.TokenIDA,
		arg.ChainIDA,
		arg.MinBalanceA,
		arg.TokenIDB,
		arg.ChainIDB,
		arg.MinBalanceB,
		arg.TokenIDA,
		arg.ChainIDA,
		arg.MinBalanceA,
		arg.TokenIDB,
		arg.ChainIDB,
		arg.MinBalanceB,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OROperatorRow
	for rows.Next() {
		var i OROperatorRow
		if err := rows.Scan(&i.HolderID, &i.BalanceA, &i.BalanceB); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHolderByTokenIDAndBlockIDAndHolderID = `-- name: TokenHolderByTokenIDAndBlockIDAndHolderID :one
SELECT holders.id, token_holders.balance
FROM holders
JOIN token_holders ON holders.id = token_holders.holder_id
WHERE token_holders.token_id = ? AND token_holders.holder_id = ? AND token_holders.block_id = ?
`

type TokenHolderByTokenIDAndBlockIDAndHolderIDParams struct {
	TokenID  annotations.Address
	HolderID annotations.Address
	BlockID  uint64
}

type TokenHolderByTokenIDAndBlockIDAndHolderIDRow struct {
	ID      annotations.Address
	Balance []byte
}

func (q *Queries) TokenHolderByTokenIDAndBlockIDAndHolderID(ctx context.Context, arg TokenHolderByTokenIDAndBlockIDAndHolderIDParams) (TokenHolderByTokenIDAndBlockIDAndHolderIDRow, error) {
	row := q.db.QueryRowContext(ctx, tokenHolderByTokenIDAndBlockIDAndHolderID, arg.TokenID, arg.HolderID, arg.BlockID)
	var i TokenHolderByTokenIDAndBlockIDAndHolderIDRow
	err := row.Scan(&i.ID, &i.Balance)
	return i, err
}

const tokenHolderByTokenIDAndHolderID = `-- name: TokenHolderByTokenIDAndHolderID :one
SELECT holders.id, token_holders.token_id, token_holders.holder_id, token_holders.balance, token_holders.block_id, token_holders.chain_id, token_holders.external_id
FROM holders
JOIN token_holders ON holders.id = token_holders.holder_id
WHERE token_holders.token_id = ? 
AND token_holders.chain_id = ?
AND token_holders.holder_id = ?
`

type TokenHolderByTokenIDAndHolderIDParams struct {
	TokenID  annotations.Address
	ChainID  uint64
	HolderID annotations.Address
}

type TokenHolderByTokenIDAndHolderIDRow struct {
	ID         annotations.Address
	TokenID    annotations.Address
	HolderID   annotations.Address
	Balance    []byte
	BlockID    uint64
	ChainID    uint64
	ExternalID string
}

func (q *Queries) TokenHolderByTokenIDAndHolderID(ctx context.Context, arg TokenHolderByTokenIDAndHolderIDParams) (TokenHolderByTokenIDAndHolderIDRow, error) {
	row := q.db.QueryRowContext(ctx, tokenHolderByTokenIDAndHolderID, arg.TokenID, arg.ChainID, arg.HolderID)
	var i TokenHolderByTokenIDAndHolderIDRow
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.HolderID,
		&i.Balance,
		&i.BlockID,
		&i.ChainID,
		&i.ExternalID,
	)
	return i, err
}

const tokenHolderByTokenIDAndHolderIDAndChainIDAndExternalID = `-- name: TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalID :one
SELECT holders.id, token_holders.token_id, token_holders.holder_id, token_holders.balance, token_holders.block_id, token_holders.chain_id, token_holders.external_id
FROM holders
JOIN token_holders ON holders.id = token_holders.holder_id
WHERE token_holders.token_id = ? 
    AND token_holders.holder_id = ? 
    AND token_holders.chain_id = ?
    AND token_holders.external_id = ?
`

type TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalIDParams struct {
	TokenID    annotations.Address
	HolderID   annotations.Address
	ChainID    uint64
	ExternalID string
}

type TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalIDRow struct {
	ID         annotations.Address
	TokenID    annotations.Address
	HolderID   annotations.Address
	Balance    []byte
	BlockID    uint64
	ChainID    uint64
	ExternalID string
}

func (q *Queries) TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalID(ctx context.Context, arg TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalIDParams) (TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalIDRow, error) {
	row := q.db.QueryRowContext(ctx, tokenHolderByTokenIDAndHolderIDAndChainIDAndExternalID,
		arg.TokenID,
		arg.HolderID,
		arg.ChainID,
		arg.ExternalID,
	)
	var i TokenHolderByTokenIDAndHolderIDAndChainIDAndExternalIDRow
	err := row.Scan(
		&i.ID,
		&i.TokenID,
		&i.HolderID,
		&i.Balance,
		&i.BlockID,
		&i.ChainID,
		&i.ExternalID,
	)
	return i, err
}

const tokenHoldersByStrategyID = `-- name: TokenHoldersByStrategyID :many
SELECT token_holders.holder_id, token_holders.balance
FROM token_holders
JOIN strategy_tokens ON strategy_tokens.token_id = token_holders.token_id
WHERE strategy_tokens.strategy_id = ?
    AND token_holders.balance >= strategy_tokens.min_balance
`

type TokenHoldersByStrategyIDRow struct {
	HolderID annotations.Address
	Balance  []byte
}

func (q *Queries) TokenHoldersByStrategyID(ctx context.Context, strategyID uint64) ([]TokenHoldersByStrategyIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByStrategyID, strategyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenHoldersByStrategyIDRow
	for rows.Next() {
		var i TokenHoldersByStrategyIDRow
		if err := rows.Scan(&i.HolderID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenID = `-- name: TokenHoldersByTokenID :many
SELECT holders.id, token_holders.balance
FROM holders
JOIN token_holders ON holders.id = token_holders.holder_id
WHERE token_holders.token_id = ?
`

type TokenHoldersByTokenIDRow struct {
	ID      annotations.Address
	Balance []byte
}

func (q *Queries) TokenHoldersByTokenID(ctx context.Context, tokenID annotations.Address) ([]TokenHoldersByTokenIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenID, tokenID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenHoldersByTokenIDRow
	for rows.Next() {
		var i TokenHoldersByTokenIDRow
		if err := rows.Scan(&i.ID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenIDAndChainIDAndExternalID = `-- name: TokenHoldersByTokenIDAndChainIDAndExternalID :many
SELECT holders.id, token_holders.balance
FROM holders
JOIN token_holders ON holders.id = token_holders.holder_id
WHERE token_holders.token_id = ? AND token_holders.chain_id = ? AND token_holders.external_id = ?
`

type TokenHoldersByTokenIDAndChainIDAndExternalIDParams struct {
	TokenID    annotations.Address
	ChainID    uint64
	ExternalID string
}

type TokenHoldersByTokenIDAndChainIDAndExternalIDRow struct {
	ID      annotations.Address
	Balance []byte
}

func (q *Queries) TokenHoldersByTokenIDAndChainIDAndExternalID(ctx context.Context, arg TokenHoldersByTokenIDAndChainIDAndExternalIDParams) ([]TokenHoldersByTokenIDAndChainIDAndExternalIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenIDAndChainIDAndExternalID, arg.TokenID, arg.ChainID, arg.ExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenHoldersByTokenIDAndChainIDAndExternalIDRow
	for rows.Next() {
		var i TokenHoldersByTokenIDAndChainIDAndExternalIDRow
		if err := rows.Scan(&i.ID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenIDAndChainIDAndMinBalance = `-- name: TokenHoldersByTokenIDAndChainIDAndMinBalance :many
SELECT token_holders.holder_id, token_holders.balance
FROM token_holders
WHERE token_holders.token_id = ? 
    AND token_holders.chain_id = ?
    AND token_holders.balance >= ?
`

type TokenHoldersByTokenIDAndChainIDAndMinBalanceParams struct {
	TokenID annotations.Address
	ChainID uint64
	Balance []byte
}

type TokenHoldersByTokenIDAndChainIDAndMinBalanceRow struct {
	HolderID annotations.Address
	Balance  []byte
}

func (q *Queries) TokenHoldersByTokenIDAndChainIDAndMinBalance(ctx context.Context, arg TokenHoldersByTokenIDAndChainIDAndMinBalanceParams) ([]TokenHoldersByTokenIDAndChainIDAndMinBalanceRow, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenIDAndChainIDAndMinBalance, arg.TokenID, arg.ChainID, arg.Balance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenHoldersByTokenIDAndChainIDAndMinBalanceRow
	for rows.Next() {
		var i TokenHoldersByTokenIDAndChainIDAndMinBalanceRow
		if err := rows.Scan(&i.HolderID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenIDAndExternalID = `-- name: TokenHoldersByTokenIDAndExternalID :many
SELECT holders.id, token_holders.balance
FROM holders
JOIN token_holders ON holders.id = token_holders.holder_id
WHERE token_holders.token_id = ? AND token_holders.external_id = ?
`

type TokenHoldersByTokenIDAndExternalIDParams struct {
	TokenID    annotations.Address
	ExternalID string
}

type TokenHoldersByTokenIDAndExternalIDRow struct {
	ID      annotations.Address
	Balance []byte
}

func (q *Queries) TokenHoldersByTokenIDAndExternalID(ctx context.Context, arg TokenHoldersByTokenIDAndExternalIDParams) ([]TokenHoldersByTokenIDAndExternalIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenIDAndExternalID, arg.TokenID, arg.ExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenHoldersByTokenIDAndExternalIDRow
	for rows.Next() {
		var i TokenHoldersByTokenIDAndExternalIDRow
		if err := rows.Scan(&i.ID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokensByHolderID = `-- name: TokensByHolderID :many
SELECT tokens.id, tokens.name, tokens.symbol, tokens.decimals, tokens.total_supply, tokens.creation_block, tokens.type_id, tokens.synced, tokens.tags, tokens.chain_id, tokens.chain_address, tokens.external_id, tokens.default_strategy
FROM tokens
JOIN token_holders ON tokens.id = token_holders.token_id
WHERE token_holders.holder_id = ?
`

func (q *Queries) TokensByHolderID(ctx context.Context, holderID annotations.Address) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, tokensByHolderID, holderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
			&i.Synced,
			&i.Tags,
			&i.ChainID,
			&i.ChainAddress,
			&i.ExternalID,
			&i.DefaultStrategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTokenHolderBalance = `-- name: UpdateTokenHolderBalance :execresult
UPDATE token_holders
SET balance = ?,
    block_id = ?
WHERE token_id = ? 
    AND holder_id = ? 
    AND block_id = ? 
    AND chain_id = ? 
    AND external_id = ?
`

type UpdateTokenHolderBalanceParams struct {
	Balance    []byte
	NewBlockID uint64
	TokenID    annotations.Address
	HolderID   annotations.Address
	BlockID    uint64
	ChainID    uint64
	ExternalID string
}

func (q *Queries) UpdateTokenHolderBalance(ctx context.Context, arg UpdateTokenHolderBalanceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTokenHolderBalance,
		arg.Balance,
		arg.NewBlockID,
		arg.TokenID,
		arg.HolderID,
		arg.BlockID,
		arg.ChainID,
		arg.ExternalID,
	)
}
