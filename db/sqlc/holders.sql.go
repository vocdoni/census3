// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: holders.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/vocdoni/census3/db/annotations"
)

const countTokenHoldersByTokenID = `-- name: CountTokenHoldersByTokenID :one
SELECT COUNT(holder_id) 
FROM TokenHolders
WHERE token_id = $1
`

func (q *Queries) CountTokenHoldersByTokenID(ctx context.Context, tokenID annotations.Address) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTokenHoldersByTokenID, tokenID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHolder = `-- name: CreateHolder :execresult
INSERT INTO Holders (id)
VALUES ($1)
`

func (q *Queries) CreateHolder(ctx context.Context, id annotations.Address) (sql.Result, error) {
	return q.db.ExecContext(ctx, createHolder, id)
}

const createTokenHolder = `-- name: CreateTokenHolder :execresult
INSERT INTO TokenHolders (
    token_id,
    holder_id,
    balance,
    block_id
)
VALUES (
    $1, $2, $3, $4
)
`

type CreateTokenHolderParams struct {
	TokenID  annotations.Address
	HolderID annotations.Address
	Balance  annotations.BigInt
	BlockID  int64
}

func (q *Queries) CreateTokenHolder(ctx context.Context, arg CreateTokenHolderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTokenHolder,
		arg.TokenID,
		arg.HolderID,
		arg.Balance,
		arg.BlockID,
	)
}

const deleteHolder = `-- name: DeleteHolder :execresult
DELETE FROM Holders
WHERE id = $1
`

func (q *Queries) DeleteHolder(ctx context.Context, id annotations.Address) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteHolder, id)
}

const deleteTokenHolder = `-- name: DeleteTokenHolder :execresult
DELETE FROM TokenHolders
WHERE token_id = $1 AND holder_id = $2
`

type DeleteTokenHolderParams struct {
	TokenID  annotations.Address
	HolderID annotations.Address
}

func (q *Queries) DeleteTokenHolder(ctx context.Context, arg DeleteTokenHolderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteTokenHolder, arg.TokenID, arg.HolderID)
}

const holderByID = `-- name: HolderByID :one
SELECT id FROM Holders
WHERE id = $1
LIMIT 1
`

func (q *Queries) HolderByID(ctx context.Context, id annotations.Address) (annotations.Address, error) {
	row := q.db.QueryRowContext(ctx, holderByID, id)
	err := row.Scan(&id)
	return id, err
}

const lastBlockByTokenID = `-- name: LastBlockByTokenID :one
SELECT block_id 
FROM TokenHolders
WHERE token_id = $1
ORDER BY block_id DESC
LIMIT 1
`

func (q *Queries) LastBlockByTokenID(ctx context.Context, tokenID annotations.Address) (int64, error) {
	row := q.db.QueryRowContext(ctx, lastBlockByTokenID, tokenID)
	var block_id int64
	err := row.Scan(&block_id)
	return block_id, err
}

const paginatedHolders = `-- name: PaginatedHolders :many
SELECT id FROM Holders
ORDER BY id
LIMIT $1 OFFSET $2
`

type PaginatedHoldersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) PaginatedHolders(ctx context.Context, arg PaginatedHoldersParams) ([]annotations.Address, error) {
	rows, err := q.db.QueryContext(ctx, paginatedHolders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []annotations.Address
	for rows.Next() {
		var id annotations.Address
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHolderByTokenIDAndBlockIDAndHolderID = `-- name: TokenHolderByTokenIDAndBlockIDAndHolderID :one
SELECT holders.id, TokenHolders.balance
FROM Holders
JOIN TokenHolders ON Holders.id = TokenHolders.holder_id
WHERE TokenHolders.token_id = $1 AND TokenHolders.holder_id = $2 AND TokenHolders.block_id = $3
`

type TokenHolderByTokenIDAndBlockIDAndHolderIDParams struct {
	TokenID  annotations.Address
	HolderID annotations.Address
	BlockID  int64
}

type TokenHolderByTokenIDAndBlockIDAndHolderIDRow struct {
	ID      annotations.Address
	Balance annotations.BigInt
}

func (q *Queries) TokenHolderByTokenIDAndBlockIDAndHolderID(ctx context.Context, arg TokenHolderByTokenIDAndBlockIDAndHolderIDParams) (TokenHolderByTokenIDAndBlockIDAndHolderIDRow, error) {
	row := q.db.QueryRowContext(ctx, tokenHolderByTokenIDAndBlockIDAndHolderID, arg.TokenID, arg.HolderID, arg.BlockID)
	var i TokenHolderByTokenIDAndBlockIDAndHolderIDRow
	err := row.Scan(&i.ID, &i.Balance)
	return i, err
}

const tokenHolderByTokenIDAndHolderID = `-- name: TokenHolderByTokenIDAndHolderID :one
SELECT holders.id, TokenHolders.balance
FROM Holders
JOIN TokenHolders ON Holders.id = TokenHolders.holder_id
WHERE TokenHolders.token_id = $1 AND TokenHolders.holder_id = $2
`

type TokenHolderByTokenIDAndHolderIDParams struct {
	TokenID  annotations.Address
	HolderID annotations.Address
}

type TokenHolderByTokenIDAndHolderIDRow struct {
	ID      annotations.Address
	Balance annotations.BigInt
}

func (q *Queries) TokenHolderByTokenIDAndHolderID(ctx context.Context, arg TokenHolderByTokenIDAndHolderIDParams) (TokenHolderByTokenIDAndHolderIDRow, error) {
	row := q.db.QueryRowContext(ctx, tokenHolderByTokenIDAndHolderID, arg.TokenID, arg.HolderID)
	var i TokenHolderByTokenIDAndHolderIDRow
	err := row.Scan(&i.ID, &i.Balance)
	return i, err
}

const tokenHoldersByTokenID = `-- name: TokenHoldersByTokenID :many
SELECT holders.id, TokenHolders.balance
FROM Holders
JOIN TokenHolders ON Holders.id = TokenHolders.holder_id
WHERE TokenHolders.token_id = $1
LIMIT $2 OFFSET $3
`

type TokenHoldersByTokenIDParams struct {
	TokenID annotations.Address
	Limit   int32
	Offset  int32
}

type TokenHoldersByTokenIDRow struct {
	ID      annotations.Address
	Balance annotations.BigInt
}

func (q *Queries) TokenHoldersByTokenID(ctx context.Context, arg TokenHoldersByTokenIDParams) ([]TokenHoldersByTokenIDRow, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenID, arg.TokenID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenHoldersByTokenIDRow
	for rows.Next() {
		var i TokenHoldersByTokenIDRow
		if err := rows.Scan(&i.ID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenIDAndBlockID = `-- name: TokenHoldersByTokenIDAndBlockID :many
SELECT holders.id
FROM Holders
JOIN TokenHolders ON Holders.id = TokenHolders.holder_id
WHERE TokenHolders.token_id = $1 AND TokenHolders.block_id = $2
LIMIT $3 OFFSET $4
`

type TokenHoldersByTokenIDAndBlockIDParams struct {
	TokenID annotations.Address
	BlockID int64
	Limit   int32
	Offset  int32
}

func (q *Queries) TokenHoldersByTokenIDAndBlockID(ctx context.Context, arg TokenHoldersByTokenIDAndBlockIDParams) ([]annotations.Address, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenIDAndBlockID,
		arg.TokenID,
		arg.BlockID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []annotations.Address
	for rows.Next() {
		var id annotations.Address
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenIDAndBlockIDAndMinBalance = `-- name: TokenHoldersByTokenIDAndBlockIDAndMinBalance :many
SELECT holders.id
FROM Holders
JOIN TokenHolders ON Holders.id = TokenHolders.holder_id
WHERE TokenHolders.token_id = $1 AND TokenHolders.balance >= $2 AND TokenHolders.block_id = $3
LIMIT $4 OFFSET $5
`

type TokenHoldersByTokenIDAndBlockIDAndMinBalanceParams struct {
	TokenID annotations.Address
	Balance annotations.BigInt
	BlockID int64
	Limit   int32
	Offset  int32
}

func (q *Queries) TokenHoldersByTokenIDAndBlockIDAndMinBalance(ctx context.Context, arg TokenHoldersByTokenIDAndBlockIDAndMinBalanceParams) ([]annotations.Address, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenIDAndBlockIDAndMinBalance,
		arg.TokenID,
		arg.Balance,
		arg.BlockID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []annotations.Address
	for rows.Next() {
		var id annotations.Address
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersByTokenIDAndMinBalance = `-- name: TokenHoldersByTokenIDAndMinBalance :many
SELECT holders.id
FROM Holders
JOIN TokenHolders ON Holders.id = TokenHolders.holder_id
WHERE TokenHolders.token_id = $1 AND TokenHolders.balance >= $2
LIMIT $3 OFFSET $4
`

type TokenHoldersByTokenIDAndMinBalanceParams struct {
	TokenID annotations.Address
	Balance annotations.BigInt
	Limit   int32
	Offset  int32
}

func (q *Queries) TokenHoldersByTokenIDAndMinBalance(ctx context.Context, arg TokenHoldersByTokenIDAndMinBalanceParams) ([]annotations.Address, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersByTokenIDAndMinBalance,
		arg.TokenID,
		arg.Balance,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []annotations.Address
	for rows.Next() {
		var id annotations.Address
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenHoldersPaginated = `-- name: TokenHoldersPaginated :many
SELECT token_id, holder_id, balance, block_id FROM TokenHolders
ORDER BY token_id, holder_id, block_id
LIMIT $1 OFFSET $2
`

type TokenHoldersPaginatedParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) TokenHoldersPaginated(ctx context.Context, arg TokenHoldersPaginatedParams) ([]Tokenholder, error) {
	rows, err := q.db.QueryContext(ctx, tokenHoldersPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tokenholder
	for rows.Next() {
		var i Tokenholder
		if err := rows.Scan(
			&i.TokenID,
			&i.HolderID,
			&i.Balance,
			&i.BlockID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokensByHolderID = `-- name: TokensByHolderID :many
SELECT tokens.id, tokens.name, tokens.symbol, tokens.decimals, tokens.total_supply, tokens.creation_block, tokens.type_id
FROM Tokens
JOIN TokenHolders ON Tokens.id = TokenHolders.token_id
WHERE TokenHolders.holder_id = $1
LIMIT $2 OFFSET $3
`

type TokensByHolderIDParams struct {
	HolderID annotations.Address
	Limit    int32
	Offset   int32
}

func (q *Queries) TokensByHolderID(ctx context.Context, arg TokensByHolderIDParams) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, tokensByHolderID, arg.HolderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokensByHolderIDAndBlockID = `-- name: TokensByHolderIDAndBlockID :many
SELECT tokens.id, tokens.name, tokens.symbol, tokens.decimals, tokens.total_supply, tokens.creation_block, tokens.type_id
FROM Tokens
JOIN TokenHolders ON Tokens.id = TokenHolders.token_id
WHERE TokenHolders.holder_id = $1 AND TokenHolders.block_id = $2
LIMIT $3 OFFSET $4
`

type TokensByHolderIDAndBlockIDParams struct {
	HolderID annotations.Address
	BlockID  int64
	Limit    int32
	Offset   int32
}

func (q *Queries) TokensByHolderIDAndBlockID(ctx context.Context, arg TokensByHolderIDAndBlockIDParams) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, tokensByHolderIDAndBlockID,
		arg.HolderID,
		arg.BlockID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.TotalSupply,
			&i.CreationBlock,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTokenHolder = `-- name: UpdateTokenHolder :execresult
UPDATE TokenHolders
SET balance = $1,
    block_id = $2
WHERE token_id = $3 AND holder_id = $4 AND block_id = $2
`

type UpdateTokenHolderParams struct {
	Balance  annotations.BigInt
	BlockID  int64
	TokenID  annotations.Address
	HolderID annotations.Address
}

func (q *Queries) UpdateTokenHolder(ctx context.Context, arg UpdateTokenHolderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTokenHolder,
		arg.Balance,
		arg.BlockID,
		arg.TokenID,
		arg.HolderID,
	)
}
