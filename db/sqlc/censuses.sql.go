// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: censuses.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/vocdoni/census3/db/annotations"
)

const censusByID = `-- name: CensusByID :one
SELECT id, strategy_id, merkle_root, uri, size, weight, census_type, queue_id FROM censuses
WHERE id = ?
LIMIT 1
`

func (q *Queries) CensusByID(ctx context.Context, id uint64) (Censuse, error) {
	row := q.db.QueryRowContext(ctx, censusByID, id)
	var i Censuse
	err := row.Scan(
		&i.ID,
		&i.StrategyID,
		&i.MerkleRoot,
		&i.Uri,
		&i.Size,
		&i.Weight,
		&i.CensusType,
		&i.QueueID,
	)
	return i, err
}

const censusByMerkleRoot = `-- name: CensusByMerkleRoot :one
SELECT id, strategy_id, merkle_root, uri, size, weight, census_type, queue_id FROM censuses
WHERE merkle_root = ?
LIMIT 1
`

func (q *Queries) CensusByMerkleRoot(ctx context.Context, merkleRoot annotations.Hash) (Censuse, error) {
	row := q.db.QueryRowContext(ctx, censusByMerkleRoot, merkleRoot)
	var i Censuse
	err := row.Scan(
		&i.ID,
		&i.StrategyID,
		&i.MerkleRoot,
		&i.Uri,
		&i.Size,
		&i.Weight,
		&i.CensusType,
		&i.QueueID,
	)
	return i, err
}

const censusByQueueID = `-- name: CensusByQueueID :one
SELECT id, strategy_id, merkle_root, uri, size, weight, census_type, queue_id FROM censuses
WHERE queue_id = ?
LIMIT 1
`

func (q *Queries) CensusByQueueID(ctx context.Context, queueID string) (Censuse, error) {
	row := q.db.QueryRowContext(ctx, censusByQueueID, queueID)
	var i Censuse
	err := row.Scan(
		&i.ID,
		&i.StrategyID,
		&i.MerkleRoot,
		&i.Uri,
		&i.Size,
		&i.Weight,
		&i.CensusType,
		&i.QueueID,
	)
	return i, err
}

const censusByStrategyID = `-- name: CensusByStrategyID :many
SELECT id, strategy_id, merkle_root, uri, size, weight, census_type, queue_id FROM censuses
WHERE strategy_id = ?
`

func (q *Queries) CensusByStrategyID(ctx context.Context, strategyID uint64) ([]Censuse, error) {
	rows, err := q.db.QueryContext(ctx, censusByStrategyID, strategyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Censuse
	for rows.Next() {
		var i Censuse
		if err := rows.Scan(
			&i.ID,
			&i.StrategyID,
			&i.MerkleRoot,
			&i.Uri,
			&i.Size,
			&i.Weight,
			&i.CensusType,
			&i.QueueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const censusByURI = `-- name: CensusByURI :one
SELECT id, strategy_id, merkle_root, uri, size, weight, census_type, queue_id FROM censuses
WHERE uri = ?
LIMIT 1
`

func (q *Queries) CensusByURI(ctx context.Context, uri sql.NullString) (Censuse, error) {
	row := q.db.QueryRowContext(ctx, censusByURI, uri)
	var i Censuse
	err := row.Scan(
		&i.ID,
		&i.StrategyID,
		&i.MerkleRoot,
		&i.Uri,
		&i.Size,
		&i.Weight,
		&i.CensusType,
		&i.QueueID,
	)
	return i, err
}

const censusesByTokenID = `-- name: CensusesByTokenID :many
SELECT c.id, c.strategy_id, c.merkle_root, c.uri, c.size, c.weight, c.census_type, c.queue_id FROM censuses AS c
JOIN strategy_tokens AS st ON c.strategy_id = st.strategy_id
WHERE st.token_id = ?
LIMIT ? OFFSET ?
`

type CensusesByTokenIDParams struct {
	TokenID []byte
	Limit   int32
	Offset  int32
}

func (q *Queries) CensusesByTokenID(ctx context.Context, arg CensusesByTokenIDParams) ([]Censuse, error) {
	rows, err := q.db.QueryContext(ctx, censusesByTokenID, arg.TokenID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Censuse
	for rows.Next() {
		var i Censuse
		if err := rows.Scan(
			&i.ID,
			&i.StrategyID,
			&i.MerkleRoot,
			&i.Uri,
			&i.Size,
			&i.Weight,
			&i.CensusType,
			&i.QueueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const censusesByTokenType = `-- name: CensusesByTokenType :many
SELECT c.id, c.strategy_id, c.merkle_root, c.uri, c.size, c.weight, c.census_type, c.queue_id FROM censuses AS c
JOIN strategy_tokens AS st ON c.strategy_id = st.strategy_id
JOIN tokens AS t ON st.token_id = t.id
JOIN token_types AS tt ON t.type_id = tt.id
WHERE tt.type_name = ?
`

func (q *Queries) CensusesByTokenType(ctx context.Context, typeName string) ([]Censuse, error) {
	rows, err := q.db.QueryContext(ctx, censusesByTokenType, typeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Censuse
	for rows.Next() {
		var i Censuse
		if err := rows.Scan(
			&i.ID,
			&i.StrategyID,
			&i.MerkleRoot,
			&i.Uri,
			&i.Size,
			&i.Weight,
			&i.CensusType,
			&i.QueueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCensus = `-- name: CreateCensus :execresult
INSERT INTO censuses (
    id,
    strategy_id,
    merkle_root,
    uri,
    size, 
    weight,
    census_type,
    queue_id
)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateCensusParams struct {
	ID         uint64
	StrategyID uint64
	MerkleRoot annotations.Hash
	Uri        sql.NullString
	Size       uint64
	Weight     sql.NullString
	CensusType uint64
	QueueID    string
}

func (q *Queries) CreateCensus(ctx context.Context, arg CreateCensusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCensus,
		arg.ID,
		arg.StrategyID,
		arg.MerkleRoot,
		arg.Uri,
		arg.Size,
		arg.Weight,
		arg.CensusType,
		arg.QueueID,
	)
}

const deleteCensus = `-- name: DeleteCensus :execresult
DELETE FROM censuses
WHERE id = ?
`

func (q *Queries) DeleteCensus(ctx context.Context, id uint64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteCensus, id)
}

const lastCensusID = `-- name: LastCensusID :one
SELECT id 
FROM censuses 
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) LastCensusID(ctx context.Context) (uint64, error) {
	row := q.db.QueryRowContext(ctx, lastCensusID)
	var id uint64
	err := row.Scan(&id)
	return id, err
}

const listCensuses = `-- name: ListCensuses :many
SELECT id, strategy_id, merkle_root, uri, size, weight, census_type, queue_id FROM censuses
ORDER BY id
`

func (q *Queries) ListCensuses(ctx context.Context) ([]Censuse, error) {
	rows, err := q.db.QueryContext(ctx, listCensuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Censuse
	for rows.Next() {
		var i Censuse
		if err := rows.Scan(
			&i.ID,
			&i.StrategyID,
			&i.MerkleRoot,
			&i.Uri,
			&i.Size,
			&i.Weight,
			&i.CensusType,
			&i.QueueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCensus = `-- name: UpdateCensus :execresult
UPDATE censuses
SET merkle_root = ?,
    uri = ?,
    size = ?,
    weight = ?
WHERE id = ?
`

type UpdateCensusParams struct {
	MerkleRoot annotations.Hash
	Uri        sql.NullString
	Size       uint64
	Weight     sql.NullString
	ID         uint64
}

func (q *Queries) UpdateCensus(ctx context.Context, arg UpdateCensusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateCensus,
		arg.MerkleRoot,
		arg.Uri,
		arg.Size,
		arg.Weight,
		arg.ID,
	)
}
