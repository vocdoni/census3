// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: strategies.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/vocdoni/census3/db/annotations"
)

const createStategy = `-- name: CreateStategy :execresult
INSERT INTO Strategies (predicate)
VALUES (?)
`

func (q *Queries) CreateStategy(ctx context.Context, predicate string) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStategy, predicate)
}

const createStrategyToken = `-- name: CreateStrategyToken :execresult
INSERT INTO StrategyTokens (
    strategy_id,
    token_id,
    min_balance,
    method_hash
)
VALUES (
    ?, ?, ?, ?
)
`

type CreateStrategyTokenParams struct {
	StrategyID int64
	TokenID    annotations.Address
	MinBalance annotations.BigInt
	MethodHash annotations.MethodHash
}

func (q *Queries) CreateStrategyToken(ctx context.Context, arg CreateStrategyTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStrategyToken,
		arg.StrategyID,
		arg.TokenID,
		arg.MinBalance,
		arg.MethodHash,
	)
}

const deleteStrategy = `-- name: DeleteStrategy :execresult
DELETE FROM Strategies
WHERE id = ?
`

func (q *Queries) DeleteStrategy(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteStrategy, id)
}

const deleteStrategyToken = `-- name: DeleteStrategyToken :execresult
DELETE FROM StrategyTokens
WHERE strategy_id = ? AND token_id = ?
`

type DeleteStrategyTokenParams struct {
	StrategyID int64
	TokenID    annotations.Address
}

func (q *Queries) DeleteStrategyToken(ctx context.Context, arg DeleteStrategyTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteStrategyToken, arg.StrategyID, arg.TokenID)
}

const paginatedStrategies = `-- name: PaginatedStrategies :many
SELECT id, predicate FROM Strategies
ORDER BY id
LIMIT ? OFFSET ?
`

type PaginatedStrategiesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) PaginatedStrategies(ctx context.Context, arg PaginatedStrategiesParams) ([]Strategy, error) {
	rows, err := q.db.QueryContext(ctx, paginatedStrategies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Strategy
	for rows.Next() {
		var i Strategy
		if err := rows.Scan(&i.ID, &i.Predicate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedStrategiesByTokenID = `-- name: PaginatedStrategiesByTokenID :many
SELECT s.id, s.predicate FROM Strategies s
JOIN StrategyTokens st ON st.strategy_id = s.id
WHERE st.token_id = ?
ORDER BY s.id
LIMIT ? OFFSET ?
`

type PaginatedStrategiesByTokenIDParams struct {
	TokenID annotations.Address
	Limit   int32
	Offset  int32
}

func (q *Queries) PaginatedStrategiesByTokenID(ctx context.Context, arg PaginatedStrategiesByTokenIDParams) ([]Strategy, error) {
	rows, err := q.db.QueryContext(ctx, paginatedStrategiesByTokenID, arg.TokenID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Strategy
	for rows.Next() {
		var i Strategy
		if err := rows.Scan(&i.ID, &i.Predicate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedStrategyTokens = `-- name: PaginatedStrategyTokens :many
SELECT strategy_id, token_id, min_balance, method_hash
FROM StrategyTokens
ORDER BY strategy_id, token_id
LIMIT ? OFFSET ?
`

type PaginatedStrategyTokensParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) PaginatedStrategyTokens(ctx context.Context, arg PaginatedStrategyTokensParams) ([]Strategytoken, error) {
	rows, err := q.db.QueryContext(ctx, paginatedStrategyTokens, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Strategytoken
	for rows.Next() {
		var i Strategytoken
		if err := rows.Scan(
			&i.StrategyID,
			&i.TokenID,
			&i.MinBalance,
			&i.MethodHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const strategyByID = `-- name: StrategyByID :one
SELECT id, predicate FROM Strategies
WHERE id = ?
LIMIT 1
`

func (q *Queries) StrategyByID(ctx context.Context, id int64) (Strategy, error) {
	row := q.db.QueryRowContext(ctx, strategyByID, id)
	var i Strategy
	err := row.Scan(&i.ID, &i.Predicate)
	return i, err
}

const strategyByPredicate = `-- name: StrategyByPredicate :one
SELECT id, predicate FROM Strategies
WHERE predicate = ?
LIMIT 1
`

func (q *Queries) StrategyByPredicate(ctx context.Context, predicate string) (Strategy, error) {
	row := q.db.QueryRowContext(ctx, strategyByPredicate, predicate)
	var i Strategy
	err := row.Scan(&i.ID, &i.Predicate)
	return i, err
}

const strategyTokenByStrategyIDAndTokenID = `-- name: StrategyTokenByStrategyIDAndTokenID :one
SELECT strategy_id, token_id, min_balance, method_hash
FROM StrategyTokens
WHERE strategy_id = ? AND token_id = ?
LIMIT 1
`

type StrategyTokenByStrategyIDAndTokenIDParams struct {
	StrategyID int64
	TokenID    annotations.Address
}

func (q *Queries) StrategyTokenByStrategyIDAndTokenID(ctx context.Context, arg StrategyTokenByStrategyIDAndTokenIDParams) (Strategytoken, error) {
	row := q.db.QueryRowContext(ctx, strategyTokenByStrategyIDAndTokenID, arg.StrategyID, arg.TokenID)
	var i Strategytoken
	err := row.Scan(
		&i.StrategyID,
		&i.TokenID,
		&i.MinBalance,
		&i.MethodHash,
	)
	return i, err
}

const strategyTokenByStrategyIDAndTokenIDAndMethodHash = `-- name: StrategyTokenByStrategyIDAndTokenIDAndMethodHash :one
SELECT strategy_id, token_id, min_balance, method_hash
FROM StrategyTokens
WHERE strategy_id = ? AND token_id = ? AND method_hash = ?
`

type StrategyTokenByStrategyIDAndTokenIDAndMethodHashParams struct {
	StrategyID int64
	TokenID    annotations.Address
	MethodHash annotations.MethodHash
}

func (q *Queries) StrategyTokenByStrategyIDAndTokenIDAndMethodHash(ctx context.Context, arg StrategyTokenByStrategyIDAndTokenIDAndMethodHashParams) (Strategytoken, error) {
	row := q.db.QueryRowContext(ctx, strategyTokenByStrategyIDAndTokenIDAndMethodHash, arg.StrategyID, arg.TokenID, arg.MethodHash)
	var i Strategytoken
	err := row.Scan(
		&i.StrategyID,
		&i.TokenID,
		&i.MinBalance,
		&i.MethodHash,
	)
	return i, err
}

const updateStrategy = `-- name: UpdateStrategy :execresult
UPDATE Strategies
SET predicate = ?
WHERE id = ?
`

type UpdateStrategyParams struct {
	Predicate string
	ID        int64
}

func (q *Queries) UpdateStrategy(ctx context.Context, arg UpdateStrategyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateStrategy, arg.Predicate, arg.ID)
}

const updateStrategyToken = `-- name: UpdateStrategyToken :execresult
UPDATE StrategyTokens
SET min_balance = ?,
    method_hash = ?
WHERE strategy_id = ? AND token_id = ?
`

type UpdateStrategyTokenParams struct {
	MinBalance annotations.BigInt
	MethodHash annotations.MethodHash
	StrategyID int64
	TokenID    annotations.Address
}

func (q *Queries) UpdateStrategyToken(ctx context.Context, arg UpdateStrategyTokenParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateStrategyToken,
		arg.MinBalance,
		arg.MethodHash,
		arg.StrategyID,
		arg.TokenID,
	)
}
